package encoding_test

import (
	"bytes"
	"context"
	"crypto/rand"
	"testing"

	"github.com/v2fly/v2ray-core/v5/common"
	"github.com/v2fly/v2ray-core/v5/common/buf"
	"github.com/v2fly/v2ray-core/v5/common/net"
	"github.com/v2fly/v2ray-core/v5/common/protocol"
	"github.com/v2fly/v2ray-core/v5/common/uuid"
	"github.com/v2fly/v2ray-core/v5/proxy/vmess"
	. "github.com/v2fly/v2ray-core/v5/proxy/vmess/encoding"
)

func TestBDIRequest_IsDummyFlag(t *testing.T) {
	// 1. Setup User/Account
	id := uuid.New()
	protoID := protocol.NewID(id) // [Fix]: Create protocol.ID for MemoryAccount

	// [Fix]: Use MemoryAccount (implements interface) instead of Account (proto struct)
	account := &vmess.MemoryAccount{
		ID:       protoID,
		AlterIDs: nil,
		Security: protocol.SecurityType_AES128_GCM,
	}

	user := &protocol.MemoryUser{
		Account: account,
	}

	// 2. Create Client Session
	clientSession := NewClientSession(context.Background(), true, protocol.DefaultIDHash, 0)

	// 3. Create a Dummy Request Header
	reqHeader := &protocol.RequestHeader{
		Version:  1,
		User:     user,
		Command:  protocol.RequestCommandTCP,
		Address:  net.LocalHostIP,
		Port:     80,
		Option:   protocol.RequestOptionChunkStream,
		Security: protocol.SecurityType_AES128_GCM,
		IsDummy:  true, // <--- Testing this flag
	}

	// 4. Encode (Client Side)
	buffer := bytes.NewBuffer(nil)
	common.Must(clientSession.EncodeRequestHeader(reqHeader, buffer))

	// 5. Decode (Server Side)
	// We need a validator that recognizes the user
	validator := vmess.NewTimedUserValidator(protocol.DefaultIDHash)
	validator.Add(user)

	sessionHistory := NewSessionHistory()
	serverSession := NewServerSession(validator, sessionHistory)

	decodedHeader, err := serverSession.DecodeRequestHeader(buffer)
	common.Must(err)

	// 6. Assert
	if !decodedHeader.IsDummy {
		t.Error("Expected IsDummy to be true, but got false. Flag was lost in transit.")
	}
}

func TestBDIResponse_PaddingStripper(t *testing.T) {
	// 1. Setup Context
	id := uuid.New()
	protoID := protocol.NewID(id)
	account := &vmess.MemoryAccount{
		ID:       protoID,
		Security: protocol.SecurityType_AES128_GCM,
	}
	user := &protocol.MemoryUser{Account: account}

	clientSession := NewClientSession(context.Background(), true, protocol.DefaultIDHash, 0)

	// Helper to sync server keys to client keys (since we aren't doing full handshake)
	// We assume the server received a request with the keys generated by the client.
	validator := vmess.NewTimedUserValidator(protocol.DefaultIDHash)
	validator.Add(user)
	serverSession := NewServerSession(validator, NewSessionHistory())

	// Hack: We manually perform a request handshake just to sync the AEAD keys
	reqBuf := bytes.NewBuffer(nil)
	reqHeader := &protocol.RequestHeader{
		Version: 1, User: user, Command: protocol.RequestCommandTCP,
		Address: net.LocalHostIP, Port: 80, Option: protocol.RequestOptionChunkStream,
		Security: protocol.SecurityType_AES128_GCM,
	}
	clientSession.EncodeRequestHeader(reqHeader, reqBuf)
	serverSession.DecodeRequestHeader(reqBuf)
	// Now serverSession and clientSession share the same Body Keys

	// --- Start BDI Downlink Test ---

	// 2. Prepare BDI Response Header (Instruction: Skip 16 bytes)
	paddingSize := uint16(16)
	bdiCmd := &CommandDummy{PaddingLength: paddingSize}

	respHeader := &protocol.ResponseHeader{
		Command: bdiCmd,
	}

	// 3. Encode Response Stream (Server Side)
	wireBuffer := bytes.NewBuffer(nil)

	// A. Write Header
	serverSession.EncodeResponseHeader(respHeader, wireBuffer)

	// B. Write BODY: [Padding Bytes] + [Real Data]
	// Important: Both are encrypted by the BodyWriter
	bodyWriter, err := serverSession.EncodeResponseBody(reqHeader, wireBuffer)
	common.Must(err)

	// Inject 16 bytes of Garbage
	garbage := make([]byte, paddingSize)
	rand.Read(garbage)
	bodyWriter.WriteMultiBuffer(buf.MultiBuffer{buf.FromBytes(garbage)})

	// Inject Real Data
	realData := []byte("Hello V2Ray BDI World")
	bodyWriter.WriteMultiBuffer(buf.MultiBuffer{buf.FromBytes(realData)})

	// 4. Decode (Client Side)

	// A. Decode Header (Should detect Dummy Command and set pendingPaddingToSkip)
	decodedRespHeader, err := clientSession.DecodeResponseHeader(wireBuffer)
	common.Must(err)

	// The client logic should hide the Dummy Command from the upper layer
	if decodedRespHeader.Command != nil {
		t.Error("Client should have consumed the Dummy Command, but returned it.")
	}

	// B. Decode Body (The Stripper Logic)
	bodyReader, err := clientSession.DecodeResponseBody(reqHeader, wireBuffer)
	common.Must(err)

	// 5. Verify
	// [Fix] buf.Reader uses ReadMultiBuffer, not Read
	mb, err := bodyReader.ReadMultiBuffer()
	common.Must(err)
	defer buf.ReleaseMulti(mb) // [Corrected] Use buf.ReleaseMulti instead of mb.Release

	// Flatten the MultiBuffer to a standard byte slice for comparison
	// MultiBuffer is essentially a slice of Buffers ([]*buf.Buffer)
	result := make([]byte, 0, mb.Len())
	for _, b := range mb {
		result = append(result, b.Bytes()...)
	}

	if !bytes.Equal(result, realData) {
		t.Errorf("Stripper failed.\nExpected: %s\nGot: %s\n(Likely read garbage bytes: %v)", realData, result, result)
	}
}
